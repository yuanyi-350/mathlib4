import Mathlib

/-
A group $G$ has no nontrivial subgroups if and only if $G = \{1\}$ or $G$ is a cyclic group of prime order.

lemma 1.If every cyclic subgroup of $G$ is trival ,then $G$ is prime order
1.The case that $G$ is infinite, and we'll have it's contradicted
  Consider the cyclic group generated by g * g,i.e$\langle g * g\rangle = G$, and we'll prove it's nonetrival
  If it's trival , it's claer that it is not $\{1\}$ because $g * g \neq 1$ as we proved before
  Then $G$ We have some $n$ ,$(g * g) ^ n = g$
  so $g ^ (2 * n - 1) = 1$.This contradicts with order zero

2.The case that $G$ is finite, then we prove that $G$ have a prime order,moreover $G$ is cyclic
  we have $\forall n < orderOf g$, $\langle g ^ n\rangle = G$ as $g ^ n \neq 1$
  $(g ^ n)^(order of g/n) = 1$ and so we have $\forall n < orderOf g$, $n$ is coprime with $orderOf g$
  Hence $orderOf g$ is a prime
  and we have prove that $orderOf g = |G|$ before, so $G$ have a prime order

lemma 2. Prove that if $G$ is cyclic and of prime order, then every subgroup $H$ of $G$ have $H = G$ or $H = \{1\}$
We have : $\langle g\rangle = G$ and $\langle g\rangle \le H$.So we exactly have $H = G$

Come back to the main problem
1.If $G$ is trival, every subgroup is equal to ${1}$
2.The case of $G$ is nontrival
  2.1When $G$ only have trival subgroups, we'll prove that $G$ is cyclic and of prime order exactly by lemma1
  2.2If $G$ is cyclic and of prime order, we'll prove that $G$ only have trival subgroups
    when $H = {1}$, trivial
    when not, prove that $H = G$,exact lemma2
-/

section Special_Example_070403
/-
A group $G$ has no nontrivial subgroups if and only if $G = \{1\}$ or $G$ is a cyclic group of prime order.
-/
lemma bot_neq { G: Type* } [Group G] (H : Subgroup G)(h : ¬ H = ⊥) : ∃ g ∈ H , g ≠ 1 := by
  by_contra nh; push_neg at nh
  have : H = ⊥ := (Subgroup.eq_bot_iff_forall H).mpr fun x a => nh x a
  contradiction

lemma xtop { G: Type* } [Group G](x : G)(neq : x ≠ 1)
    (h : ∀ (g : G), Subgroup.zpowers g = ⊥ ∨ Subgroup.zpowers g = ⊤) : Subgroup.zpowers x = ⊤ := by
  rcases h x with a | a
  · have : x = 1 := Subgroup.zpowers_eq_bot.mp a
    contradiction
  · exact a

lemma part1_1 { G: Type* } [Group G](g : G) (h : ∀ (g : G), Subgroup.zpowers g = ⊥ ∨ Subgroup.zpowers g = ⊤)
    (h₁ : orderOf g = 0) : False := by
  --If $order of g = 0$ ,then $1 \ne g * g$
  have : g * g ≠ 1 := by
    by_contra ht
    have : g ^ 2 = 1 := by rw [pow_two g, ht]
    have : orderOf g ∣ 2 := orderOf_dvd_of_pow_eq_one this
    have : 0 ∣ 2 := by rw [h₁] at this; exact this
    contradiction
  --Consider the cyclic group generated by g * g,i.e$\langle g * g\rangle = G$, and we'll prove it's nonetrival
  have : g ∈ Subgroup.zpowers (g * g) := by rw[xtop (g * g) this h]; exact trivial
  rcases this with ⟨n, hn⟩
  --If it's trival , it's claer that it is not $\{1\}$ because $g * g \neq 1$ as we proved before
  --Then $G$ We have some $n$ ,$(g * g) ^ n = g$
  have : g ^ (2 * n) = g := by calc
    _ = g ^ (n + n) := by congr 1; exact Int.two_mul n
    _ = g ^ n * g ^ n := zpow_add g n n
    _ = (g * g) ^ n := Eq.symm (Commute.mul_zpow rfl n)
    _ = _ := hn
  --so $g ^ (2 * n - 1) = 1$
  have eq: g ^ (2 * n - 1) = 1 := by calc
    _ = g ^ (2 * n + -1) := rfl
    _ = g ^ (2 * n) * g ^ (-1:ℤ) := zpow_add g (2 * n) (-1)
    _ = g * g ^ (-1:ℤ) := by rw [this]
    _ = _ := by simp only [Int.reduceNeg, zpow_neg, zpow_one, mul_right_inv]
  --This contradicts with order zero
  have : (orderOf g : ℤ) ∣ (2 * n - 1) := orderOf_dvd_iff_zpow_eq_one.mpr eq
  rw [h₁] at this; norm_num at this
  have : (2 : ℤ) ∣ (1 : ℤ) := by
    use n
    calc
      _ = 0 + 1 := by norm_num
      _ = (2 * n - 1) + 1 := by rw [this]
      _ = _ := by simp only [sub_add_cancel]
  norm_num at this


lemma part1_2 { G: Type* } [Group G] (x :G)(h : ∀ (g : G), Subgroup.zpowers g = ⊥ ∨ Subgroup.zpowers g = ⊤)
    (neq : x ≠ 1) : orderOf x = Nat.card G := by
    have : ∀ (s : G), s ∈ Subgroup.zpowers x := by
      intro s; rw [xtop x neq h]; exact trivial
    exact (Nat.card_zpowers x ▸ (Nat.card_congr <| Equiv.subtypeUnivEquiv this))

--If every cyclic subgroup of $G$ is trival ,then $G$ is prime order
lemma part1 { G: Type* } [Group G] (nh : ¬⊤ = (⊥:Subgroup G))
    (h : ∀ (g : G), Subgroup.zpowers g = ⊥ ∨ Subgroup.zpowers g = ⊤): (Nat.card G).Prime := by
  rcases bot_neq ⊤ nh with ⟨g, hg⟩
  by_cases h₁ : orderOf g = 0
  · --The case that $G$ is infinite, and we'll have it's contradicted
    have : False := by exact part1_1 g h h₁
    contradiction
  · --The case that $G$ is finite, then we prove that $G$ have a prime order,moreover $G$ is cyclic
    have orderle1: orderOf g ≥ 1 := by exact Nat.one_le_iff_ne_zero.mpr h₁
    have : orderOf g ≠ 1 := by
      by_contra ntt
      have : g = 1 := orderOf_eq_one_iff.mp ntt
      have : g ≠ 1 := hg.2
      contradiction
    have orderlt1 : orderOf g > 1 := Nat.lt_of_le_of_ne orderle1 (id (Ne.symm this))
    have imp: orderOf g = Nat.card G := part1_2 g h hg.2
    have neq0: Nat.card G > 0 := by linarith[this, Nat.one_le_iff_ne_zero.mpr h₁]
    have : Finite G := (Nat.card_pos_iff.mp neq0).2
    --we have $\forall n < orderOf g$, $\langle g ^ n\rangle = G$ as $g ^ n \neq 1$
    --$(g ^ n)^(order of g/n) = 1$ and so we have $\forall n < orderOf g$, $n$ is coprime with $orderOf g$
    have : ∀ n < orderOf g , n ≠ 0 → (orderOf g).gcd n = 1 := by
      intro n nlt neq
      have imp2: orderOf (g ^ n) = Nat.card G := part1_2 (g ^ n) h (pow_ne_one_of_lt_orderOf' neq nlt)
      rw [orderOf_pow g, ←imp] at imp2
      rcases Nat.div_eq_self.mp imp2 with _ | eq
      · contradiction
      · exact eq
    --Hence $orderOf g$ is a prime
    rw [←imp]
    -- and we have prove that $orderOf g = |G|$ before, so $G$ have a prime order
    exact Nat.prime_of_coprime (orderOf g) orderlt1 this

-- #check Subgroup.eq_bot_or_eq_top_of_prime_card in Mathlib
#check zpowers_eq_top_of_prime_card

--Prove that if $G$ is cyclic and of prime order, then every subgroup $H$ of $G$ have $H = G$ or $H = \{1\}$
lemma part2 { G: Type* } [Group G] (H : Subgroup G)(h : IsCyclic G ∧ (Nat.card G).Prime)(nh₁ : ¬H = ⊥) : H = ⊤ := by
  rcases bot_neq H nh₁ with ⟨g,hx⟩
  --It is obvious that $G$ is finite
  have : Finite G := (Nat.card_pos_iff.mp (Nat.Prime.pos h.2)).2
  have : Fintype G := Fintype.ofFinite G
  let p := Nat.card G
  have hp : Fact p.Prime := { out := h.2 }
  have : Fintype.card G = p := Fintype.card_eq_nat_card
  --We have : $\langle g\rangle = G$
  have imp : Subgroup.zpowers g = ⊤ := zpowers_eq_top_of_prime_card this hx.2
  --We have : $\langle g\rangle \le H$
  have : Subgroup.zpowers g ≤ H:= by
    rintro x ⟨n, h1⟩
    rw [←h1]; apply Subgroup.zpow_mem H hx.1 n
  have : ⊤ ≤ H := by exact le_of_eq_of_le (id (Eq.symm imp)) this
  --So we exactly have $H = G$
  exact (Subgroup.eq_top_iff' H).mpr fun x ↦ this trivial

example { G: Type* } [Group G]: (∀ H : Subgroup G , H = ⊥ ∨ H = ⊤) ↔
    (⊤ : Subgroup G) = (⊥ : Subgroup G)  ∨ (IsCyclic G ∧ Nat.Prime (Nat.card G)):= by
  by_cases nh : (⊤ : Subgroup G) = (⊥ : Subgroup G)
  · --If $G$ is trival, every subgroup is equal to ${1}$
    constructor
    · intro _; left; exact nh
    · intro _ H; left; exact eq_bot_of_bot_eq_top (id (Eq.symm nh)) H
  · --The case of $G$ is nontrival
    constructor
    · --When $G$ only have trival subgroups, we'll prove that $G$ is cyclic and of prime order
      intro h; right
      rcases bot_neq ⊤ nh with ⟨g, _, hg₂⟩
      --exactly by lemma
      constructor
      · use g
        intro x
        have : Subgroup.zpowers g = ⊤ := by
          by_contra h1
          rcases (h (Subgroup.zpowers g)) with case1 | case2
          · apply hg₂; exact Subgroup.zpowers_eq_bot.mp case1
          · apply h1 case2
        rw [this]; exact trivial
      · exact part1 nh fun g ↦ h (Subgroup.zpowers g)
    · intro h H
      rcases h with h | h
      · --If $G$ is $\{1\}$,it's trival
        right; exact eq_top_of_bot_eq_top (id (Eq.symm h)) H
      · --If $G$ is cyclic and of prime order, we'll prove that $G$ only have trival subgroups
        by_cases nh₁ : H = (⊥ : Subgroup G)
        · --when $H = {1}$, trivial
          left; exact nh₁
        · --when not, prove that $H = G$,exact lemma
          right; exact part2 H h nh₁

end Special_Example_070403

--下面有类型转化的样例，有参考价值

/-museum (equal to part)
lemma typechange (m : ℤ)(p : ℕ)(h : p ≥ 1) : ∃ m₁ : ℕ , ∃ u : ℕ, m₁= p * u + m := by
  have : ∃ u : ℕ, u > -m := exists_nat_gt (-m)
  rcases this with ⟨u, hu⟩
  have : u * p + m ≥ 0 := by linarith[Nat.mul_le_mul_left u h, hu]
  use (u * p + m).toNat
  use u
  simp [this]
  exact mul_comm _ _

lemma part { G: Type* } [Group G] (H : Subgroup G)(h : IsCyclic G ∧ (Nat.card G).Prime)(nh₁ : ¬H = ⊥) : H = ⊤ := by
  let p := Nat.card G
  rcases h with ⟨⟨g, xpow⟩, p.prime⟩
  rcases bot_neq H nh₁ with ⟨g₁, ⟨in_H, neq1⟩⟩
  rcases xpow g₁ with ⟨m, pow_m⟩
  rcases typechange m p (Nat.Prime.one_le p.prime) with ⟨m₁, ⟨u, feq⟩⟩
  have powp1: g ^ p = 1 := by exact pow_card_eq_one'
  have : g ^ m₁ = g ^ m := by
    calc
      _ = g ^ (m₁ : ℤ) := by simp only [zpow_natCast]
      _ = g ^ ((p:ℤ) * (u:ℤ) + m) := by rw [feq]
      _ = g ^ ((p:ℤ) * (u:ℤ)) * g ^ m := by exact zpow_add g ((p : ℤ) * (u : ℤ)) m
      _ = (g ^ (p : ℤ)) ^ (u : ℤ) * g ^ m := by
        simp only [mul_left_inj]
        exact zpow_mul g (p : ℤ) (u : ℤ)
      _ = _ := by
        simp only [zpow_natCast, powp1, one_pow, one_mul]
  dsimp at pow_m
  rw [←this] at pow_m
  have coprime_mp: gcd m₁ p = 1 := by
    have t1: ¬gcd m₁ p = p := by
      by_contra ht
      have : g₁ = 1 := by
        calc
          _ = g ^ m₁ := by rw[pow_m]
          _ = _ := by
            apply orderOf_dvd_iff_pow_eq_one.mp
            exact Nat.dvd_trans (orderOf_dvd_natCard g) (Nat.dvd_trans (dvd_of_eq (id (Eq.symm ht))) (gcd_dvd_left m₁ p))
      contradiction
    have t2: (gcd m₁ p) = 1 ∨ (gcd m₁ p) = p := (Nat.dvd_prime p.prime).mp (gcd_dvd_right m₁ p)
    rcases t2 with t2 | t2
    · exact t2
    · by_contra
      apply t1 t2
  have : 1 = (m₁ : ℤ ) * m₁.gcdA p + (p : ℤ) * m₁.gcdB p := by
    rw [← (Nat.gcd_eq_gcd_ab m₁ p)]
    have : (m₁.gcd p) = 1 := coprime_mp
    simp [this]--simp利于处理类型转化
  have : g = g₁ ^ m₁.gcdA p := by
    calc
      _ = g ^ (1:ℤ) := by simp only [zpow_one]
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p + (p : ℤ) * m₁.gcdB p) := by simp only [this]
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p) * g ^ ((p : ℤ) * m₁.gcdB p) := by exact zpow_add g (↑m₁ * m₁.gcdA p) (↑p * m₁.gcdB p)
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p) * (g ^ (p : ℤ)) ^ (m₁.gcdB p) := by
        simp only [mul_right_inj]--直接simp?出来的是simp only [zpow_natCast, mul_right_inj]前者会破坏类型转换
        exact zpow_mul g (↑p) (m₁.gcdB p)
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p) * (g ^ p) ^ (m₁.gcdB p) := by simp only [zpow_natCast, one_zpow, mul_one]
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p) * 1 ^ (m₁.gcdB p) := by simp only [powp1, one_zpow, mul_one]
      _ = g ^ ((m₁ : ℤ ) * m₁.gcdA p) := by simp only [one_zpow, mul_one]
      _ = (g ^ (m₁ : ℤ )) ^ m₁.gcdA p := by exact zpow_mul g (↑m₁) (m₁.gcdA p)
      _ = _ := by simp only [zpow_natCast, pow_m]

  have ginH: g ∈ H := by
    rw [this]
    exact Subgroup.zpow_mem H in_H (m₁.gcdA p)
  have t1: H ≤ ⊤ := by exact fun ⦃x⦄ _ => trivial
  have t2: H ≥ ⊤ := by
    intro x _
    have Hx : ∃ n : ℤ , g ^ n = x := xpow x
    rcases Hx with ⟨n, hx⟩
    rw [←hx]
    exact Subgroup.zpow_mem H ginH n
  exact (Subgroup.eq_top_iff' H).mpr fun x => t2 (t1 (t2 trivial))
-/
